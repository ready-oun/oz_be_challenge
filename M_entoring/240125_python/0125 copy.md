# 멘토링 24.01.25

1.

## pyenv

pyenv virtualenv 설치 ==>> 버전 별로 프로젝트를 관리할 수 있음

1-1>> pyenv install 3.
=> 버전들이 나오면 설치할 버전을 고르면 됨

ㄴ>pyenv install 3.12.1

1-2>> pyenv local [추가하고 싶은 무언가]

2.  "comprehension"

# list, dict를 쉽게 만들어줌

2-1>>
numbers = range(1,10)

square_numbers = []

for number in numbers:
square_numbers.append(number \*\* 2)

print(square_numbers)

2-2>>

(2-1)을 더 쉽게 "comprehension"

square_numbers2 = [number ** 2 for number in numbers]
print(square_numbers2)

2-3>>
for number in numbers:
if number %2 != 0:
square_numbers.append(number \*\* 2)

square_numbers2 = [number ** 2 for number in numbers
if number % 2 != 0]

print(square_numbers2)

2-4>>

# list

score = [
["최지현", 90],
["김땡떙", 100],
["홍길동", 50]
]

name_with_score = {
s[0]: s[1]
for s in score
if s[1] > 50
}

print(name_with_score)

# dict

score = [
{"name": "최지현", "score": 90},
{"name": "김땡떙", "score": 100},
{"name": "홍길동", "score": 50}
]

name_with_score = {
s["name"]: s["score"]
for s in score
if s["score"] > 50
}

print(name_with_score)

3. # sort
   numbers = [1, 5, 2, 3, 4, 9]

print(sort(numbers))
print(sorted(numbers, reverse = True))

4.

# lambda

def a(x, y):
return x + y
print(a(x:1,y:2))
print((lambda x, y: x + y)(x:1, y:2))

score = [
{"name": "최지현", "score": "90"},
{"name": "김땡떙", "score": "100"},
{"name": "홍길동", "score": "50"}
]

numbers = [1, 5, 2, 3, 4, 9]

print(sorted(score, key=lambda x: x['score'], reverse = True))

list(map(lambda x: x\*\*2, range(1,10)))

5. \***\* 오늘 멘토링 중에서 가장 중요 \*\***

# match case (다른 언어들에서 switch case)

number = input('숫자를 입력해주세요 :')

number = int(number)

match number:
case 1:
print('1번을 입력하셨습니다.')
case 2:
print('2번을 입력하셨습니다.')
case \_:
print('잘못 입력하셨습니다.')

> > > > > \_(언더 바)는 위의 숫자를 제외한 나머지들

if number == 1:
print('1번을 입력하셨습니다.')
elif number == 2:
print('2번을 입력하셨습니다.')
else:
print('잘못 입력하셨습니다.)

6.  \***\* 너무나 중요한 함수라서 누군가 들어올때 마다 로그를 남기고 싶다면 \*\***

def plus(x, y):
print('plus 함수 사용합니다.')
print(f'입력값: {x, y}')
print(f'리턴값: {x, y}')
return x + y

def minus(x, y):
print('minus 함수 사용합니다.')
print(f'입력값: {x, y}')
print(f'리턴값: {x, y}')
return x- y

로그 데코레이터는 로그 함수를 받아서 실행하는 함수
-> 로그 데코레이터 안에 넣으면 그 함수를 실행하게 함
-> 입력받은 함수를 실행하게..같은 말..

def log_decorate(func):
def wrapper(*args, \*\*kwargs):
print(f'{func.**name**} 함수 사용합니다.')
print(f'입력값: {x, y}')
print(f'리턴값: {x, y}')
return func(*args, \*\*kwargs)
return wrapper

print(f'{func.**name**} 함수 사용합니다.')
print(f'입력값: {x, y}')
print(f'리턴값: {x, y}')

==>> 이건 기록만 남게 되는 거임

log_plus = log_decorator(plus)
==>>

@log_decorator
def minus(x, y):
return x - y

@log_decorator
def minus(x, y):
return x + y

> > > > > \*의 의미
> > > > > 리스트를 풀어주고 싶을때

```
numbers = [
    [1, 2], [3, 4], [5, 6]
]

for n in numbers:
    plus(*n)
    plus(*args:n[0],n[1])

** => dict에서 사용함
k_numbers = [
    {'x':1, 'y':2,}, {'x':5, 'y':7}
]

for numbers in k_numbers:
    plus(**numbers)
    plus(x=numbers['x'])
```
